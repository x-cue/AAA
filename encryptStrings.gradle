buildscript {
    repositories {
        mavenCentral()

        maven {
            url = uri('https://mvnrepository.com/artifact/org.ow2.asm/asm')
        }

        maven {
            name = 'Fabric'
            url = 'https://maven.fabricmc.net/'
        }
        gradlePluginPortal()
    }

    dependencies {
        classpath 'org.jasypt:jasypt:1.9.3'
        classpath 'org.ow2.asm:asm:9.7.1'
        classpath 'org.ow2.asm:asm-tree:9.7.1'
        classpath 'com.google.code.gson:gson:2.10.1'
    }
}

import java.util.jar.JarFile
import java.util.jar.JarOutputStream
import java.util.jar.JarEntry
import org.jasypt.util.text.AES256TextEncryptor
import org.objectweb.asm.*
import org.objectweb.asm.tree.*
import java.util.regex.Pattern

// Add the pattern to match class literals
def classLiteralPattern = Pattern.compile("^Ljava/lang/(Integer|Double|Long);\$")

task encryptStrings {
    dependsOn shadowJar
    doLast {
        def jarFile = shadowJar.archiveFile.get().asFile
        def encryptedJarFile = file("$buildDir/libs/encrypted.jar")
        String key = "poopy-stinky-poop"
        AES256TextEncryptor encryptor = new AES256TextEncryptor()
        encryptor.setPassword(key)

        JarOutputStream jos = new JarOutputStream(new FileOutputStream(encryptedJarFile))
        JarFile originalJar = new JarFile(jarFile)

        originalJar.entries().each { JarEntry entry ->
            InputStream entryInputStream = originalJar.getInputStream(entry)
            byte[] entryData = entryInputStream.bytes

            // Check if the entry is a class file and is in the com/xcue directory
            if (entry.name.endsWith('.class') && entry.name.startsWith("com/xcue/") && !entry.name.startsWith("com/xcue/lib/encryption/")) {
                try {
                    ClassReader classReader = new ClassReader(entryData)
                    ClassNode classNode = new ClassNode()
                    classReader.accept(classNode, 0)

                    // Encrypt string literals in each method
                    classNode.methods.each { MethodNode method ->
                        InsnList instructions = method.instructions
                        for (AbstractInsnNode insn : instructions.toArray()) {
                            if (insn instanceof LdcInsnNode) {
                                String originalString = insn.cst

                                // Log strings in Config.class
                                if (entry.name.endsWith("Config.class")) {
                                    println "Found string: ${originalString}"
                                }

                                // Skip class literals
                                if (classLiteralPattern.matcher(originalString).matches()) {
                                    println "Skipping class literal"
                                    continue
                                }

                                // Encrypt and replace other strings
                                String encryptedString = encryptor.encrypt(originalString)

                                // Create a new method call for decryption
                                MethodInsnNode decryptCall = new MethodInsnNode(
                                        Opcodes.INVOKESTATIC,
                                        "com/xcue/lib/encryption/Encryption",
                                        "decrypt",
                                        "(Ljava/lang/String;)Ljava/lang/String;",
                                        false
                                )

                                // Create a new LdcInsnNode for the encrypted string
                                LdcInsnNode encryptedLdc = new LdcInsnNode(encryptedString)

                                // Insert the new instructions
                                InsnList newInstructions = new InsnList()
                                newInstructions.add(encryptedLdc)  // Load the encrypted string
                                newInstructions.add(decryptCall)    // Call the decrypt method
                                instructions.insert(insn, newInstructions) // Insert before the original LdcInsnNode
                                instructions.remove(insn)             // Remove the original LdcInsnNode
                            }
                        }
                    }

                    ClassWriter classWriter = new ClassWriter(ClassWriter.COMPUTE_FRAMES)
                    classNode.accept(classWriter)
                    byte[] modifiedEntryData = classWriter.toByteArray()

                    // Write modified class file to the new jar
                    jos.putNextEntry(new JarEntry(entry.name))
                    jos.write(modifiedEntryData)
                    jos.closeEntry()
                } catch (Exception e) {
                    println "Error processing class: ${entry.name} - ${e.message}. Copying original file."
                    // Write the original entry data to the new jar instead
                    jos.putNextEntry(new JarEntry(entry.name))
                    jos.write(entryData) // Copy original contents
                    jos.closeEntry()
                }
            } else {
                // Write non-class files unchanged
                jos.putNextEntry(new JarEntry(entry.name))
                jos.write(entryData)
                jos.closeEntry()
            }
        }

        originalJar.close()
        jos.close()
    }
}
